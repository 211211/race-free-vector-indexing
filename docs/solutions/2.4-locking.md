# 2.4 Distributed Locking

**Alternative Approach** - Dùng lock để serialize reindex operations.

## Concept

Sử dụng Redis distributed lock để đảm bảo chỉ có một reindex operation chạy tại một thời điểm cho mỗi document.

```
ACQUIRE LOCK → DELETE → INSERT → RELEASE LOCK
```

**Quan trọng**: Locking giải quyết **concurrent reindex**, KHÔNG giải quyết **query miss**!

---

## Implementation

```typescript
const LOCK_TTL_SECONDS = 300;  // 5 minutes
const LOCK_RETRY_DELAY = 100;  // 100ms between retries
const MAX_LOCK_RETRIES = 50;   // Max 50 retries = 5 seconds wait

async function acquireLock(uuid: string): Promise<boolean> {
  const lockKey = `lock:${uuid}`;
  const lockValue = JSON.stringify({ lockedAt: Date.now(), pid: process.pid });

  // SET NX EX = Set if Not eXists with EXpiry
  const result = await redis.set(lockKey, lockValue, 'EX', LOCK_TTL_SECONDS, 'NX');
  return result === 'OK';
}

async function releaseLock(uuid: string): Promise<void> {
  await redis.del(`lock:${uuid}`);
}

async function reindexWithLock(documentId: string, content: string) {
  // 1. Acquire lock (wait if needed)
  const locked = await waitForLock(documentId);
  if (!locked) throw new Error('Failed to acquire lock');

  try {
    // 2. DELETE then INSERT (protected by lock)
    await qdrant.delete('chunks', {
      filter: { must: [{ key: 'uuid', match: { value: documentId } }] }
    });

    // ⚠️ GAP: Document KHÔNG TÌM THẤY trong khoảng này!
    // Lock chỉ ngăn concurrent reindex, KHÔNG ngăn query miss!

    const chunks = processDocument(content);
    await qdrant.upsert('chunks', { points: chunks });
  } finally {
    // 3. Release lock
    await releaseLock(documentId);
  }
}
```

---

## Search Implementation

```typescript
async function search(query: string): Promise<SearchResult[]> {
  const vector = generateEmbedding(query);

  // Search đơn giản - không check lock
  return qdrant.search(vector, { limit: 10 });
}
```

**Vấn đề**: Search **KHÔNG** biết document đang bị reindex → có thể trả về empty results!

---

## Timeline Chi Tiết - Tại sao vẫn có GAP?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ LOCKING REINDEX TIMELINE                                                     │
├──────┬──────────────────────────────────────────────────────────────────────┤
│ T0   │ [INDEXER] Acquire lock                                               │
│      │           Lock: lock:doc-001 = {lockedAt: T0, pid: 123}             │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T100 │ [INDEXER] DELETE chunks                                              │
│      │           Chunks: [] (EMPTY!)                                        │
│      │                                                                       │
│      │ ⚠️  DOCUMENT BIẾN MẤT! (giống Baseline)                              │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T200 │ [USER] Query "pump specs"                                            │
│      │        → Search trong Qdrant                                         │
│      │        → Không có chunks nào                                         │
│      │        → Return EMPTY RESULTS!                                       │
│      │                                                                       │
│      │ ❌ LOCK KHÔNG GIÚP GÌ CHO QUERY!                                     │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T300 │ [INDEXER-2] Cố gắng reindex cùng document                            │
│      │             → acquireLock() returns false                            │
│      │             → Wait and retry...                                      │
│      │                                                                       │
│      │ ✅ LOCK BẢO VỆ KHỎI CONCURRENT REINDEX                               │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T400 │ [INDEXER] INSERT chunks mới                                          │
│      │           Chunks: [chunk1, chunk2, chunk3]                          │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T500 │ [INDEXER] Release lock                                               │
│      │           Lock: deleted                                              │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T550 │ [INDEXER-2] acquireLock() returns true                               │
│      │             → Có thể reindex bây giờ                                 │
└──────┴──────────────────────────────────────────────────────────────────────┘

Lock BẢO VỆ:     Concurrent reindex operations
Lock KHÔNG BẢO VỆ: User queries trong lúc reindex
```

---

## FAQ: Câu hỏi thường gặp

### Q1: Lock giải quyết được gì?

**Chỉ giải quyết concurrent reindex, KHÔNG giải quyết query miss!**

| Problem | Locking giải quyết? |
|---------|-------------------|
| Concurrent reindex của cùng document | ✅ Yes |
| User query trả về empty trong lúc reindex | ❌ No |
| Data corruption từ concurrent updates | ✅ Yes |
| Service crash trong lúc reindex | ⚠️ Partial (lock TTL) |

### Q2: Tại sao availability chỉ ~75%?

Benchmark results không ổn định vì:
- **Lock chỉ serialize reindex**, không ngăn query miss
- Trong lúc reindex, document vẫn unavailable
- Kết quả dao động từ 25% đến 100% tùy timing

```
Without lock: 38% availability (baseline)
With lock:    ~75% availability (không ổn định)

Sự cải thiện đến từ: Không có data corruption từ concurrent reindex
Vẫn có vấn đề: Query miss trong lúc một reindex đang chạy
```

### Q3: Lock stuck thì sao?

**Lock có TTL để auto-expire!**

```typescript
// Lock tự động expire sau 5 phút
const LOCK_TTL_SECONDS = 300;

// Nếu worker crash trong khi giữ lock:
// - Lock bị stuck tối đa 5 phút
// - Sau đó tự động expire
// - Reindex khác có thể acquire lock
```

**Vấn đề**: 5 phút là thời gian dài - các reindex requests khác bị block!

### Q4: Có thể dùng lock cho search không?

**Có thể, nhưng không nên!**

```typescript
// ❌ BAD: Check lock trước khi search
async function searchWithLockCheck(query: string) {
  const isLocked = await redis.exists(`lock:${documentId}`);
  if (isLocked) {
    return { warning: 'Document đang được cập nhật', results: [] };
  }
  return qdrant.search(vector);
}
```

Vấn đề:
- Cần biết documentId trước khi search (không phải lúc nào cũng có)
- Thêm Redis lookup cho mỗi query = latency
- Vẫn có race condition giữa check lock và search

### Q5: Khi nào nên dùng Locking?

**Hầu như KHÔNG NÊN dùng cho vấn đề này!**

Locking phù hợp cho:
- Ngăn concurrent writes vào cùng resource
- Database transactions
- File system operations

Locking KHÔNG phù hợp cho:
- Đảm bảo query availability trong lúc update
- Giải quyết DELETE-then-INSERT gap

### Q6: Có duplicate results như Blue-Green/Soft-Delete không?

**KHÔNG có duplicate trong normal operation!**

Giống Baseline, Locking cũng dùng DELETE-then-INSERT:

```
Timeline (with lock):
T0:   [Lock acquired]
T50:  [DELETE v1]                 → Query returns EMPTY ❌
T200: [processing...]             → Query returns EMPTY ❌
T400: [INSERT v2]                 → Query returns v2
T450: [Lock released]
```

Chỉ có 1 version tồn tại tại một thời điểm (không như Blue-Green/Soft-Delete).

**Lock đảm bảo KHÔNG có concurrent reindex** → KHÔNG có duplicate từ concurrent operations.

---

## Edge Cases Summary

| Edge Case | Behavior | Mitigation |
|-----------|----------|------------|
| Empty results (GAP) | User query trả về 0 results trong lúc reindex | **KHÔNG CÓ MITIGATION** ❌ |
| Data loss on crash | Document mất vĩnh viễn nếu crash sau DELETE | **KHÔNG CÓ MITIGATION** ❌ |
| Lock stuck | Crash trong lúc hold lock → block 5 phút | TTL auto-expire, hoặc manual force release |
| Lock contention | Nhiều documents cùng reindex → queue dài | Rate limiting, priority queue |
| Redis unavailable | Không acquire được lock | Fallback: proceed without lock (risky) hoặc fail fast |
| Redis failover | Lock mất khi Redis master switch | Redlock algorithm cho high availability |
| Lock TTL too short | Reindex chưa xong, lock đã expire → concurrent | Tăng TTL hoặc implement lock extension |
| Lock TTL too long | Crash → block quá lâu | Trade-off, cần tune theo use case |
| Deadlock | Circular lock dependency (nếu lock nhiều resources) | Không apply cho single-document lock |
| Thundering herd | Lock release → nhiều waiters đồng loạt retry | Exponential backoff với jitter |
| Clock drift | TTL tính sai nếu server clocks không sync | Dùng Redis server time, không phải client time |

**So sánh với Baseline**:
- Locking giải quyết concurrent reindex (Baseline không có)
- Nhưng vẫn giữ nguyên vấn đề GAP và data loss

---

## So sánh với các Solutions khác

| Aspect | Baseline | Locking | Blue-Green | Soft-Delete |
|--------|----------|---------|------------|-------------|
| Query miss trong gap | ❌ Yes | ❌ Yes | ✅ No | ✅ No |
| Concurrent reindex safe | ❌ No | ✅ Yes | ✅ Yes | ✅ Yes |
| Availability | ~38% | ~75% | **100%** | **100%** |
| Complexity | Simple | Medium | Medium | Medium |
| External dependency | None | Redis | Redis | None |

---

## Crash Recovery

| Scenario | Result |
|----------|--------|
| Crash sau acquire lock, trước DELETE | ⚠️ Lock stuck cho đến TTL expire |
| Crash sau DELETE, trước INSERT | ❌ Document LOST + Lock stuck |
| Crash sau INSERT, trước release | ⚠️ Document OK, Lock stuck |
| Lock TTL expire | Lock auto-release, có thể retry |

**Recovery**: Manual force release lock nếu cần, hoặc wait for TTL.

---

## Benchmark Results

| Metric | Value |
|--------|-------|
| Availability | **~75%** (không ổn định, dao động 25-100%) |
| Avg Latency | 41ms (bao gồm lock wait time) |
| Storage Overhead | Không |
| Crash Recovery | ⚠️ Lock có thể stuck |
| Concurrent Safety | ✅ Yes |

---

## Code Flow

```
reindex(uuid, content)
    │
    ├─1─► waitForLock(uuid)
    │     ├─► redis.set(lock:uuid, value, 'EX', 300, 'NX')
    │     │   └─► Returns 'OK' if acquired, null if exists
    │     └─► Retry up to 50 times with 100ms delay
    │
    ├─2─► [Lock acquired]
    │     ├─► deleteByUuid(uuid)
    │     │   ⚠️ Document GONE from this point!
    │     │
    │     ├─► processDocument(content)
    │     │
    │     └─► upsertChunks(chunks)
    │         ✅ Document available again!
    │
    └─3─► [finally] releaseLock(uuid)
          └─► redis.del(lock:uuid)
```

---

## Ưu điểm

- Ngăn concurrent reindex của cùng document
- Ngăn data corruption
- Đơn giản để implement
- Redis SET NX EX là atomic

## Nhược điểm

- **KHÔNG giải quyết query miss** - vẫn có gap
- Lock contention khi nhiều documents cần reindex
- Lock stuck nếu worker crash
- Phụ thuộc vào Redis
- Availability không ổn định

---

## Kết luận

**Locking là WRONG TOOL cho vấn đề này!**

Vấn đề cần giải quyết:
> "User query trả về empty trong lúc document đang reindex"

Locking giải quyết:
> "Nhiều workers cùng reindex một document"

Đây là hai vấn đề khác nhau. Locking có thể bổ sung cho Blue-Green/Soft-Delete để thêm concurrent safety, nhưng KHÔNG thể thay thế chúng.

---

## Source Code

[src/solutions/locking.ts](../../src/solutions/locking.ts)

---

⚠️ **Không khuyến nghị** - Không giải quyết được root cause của query miss. Nếu cần concurrent safety, hãy kết hợp với Blue-Green hoặc Soft-Delete.
