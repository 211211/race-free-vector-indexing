# 2.2 Blue-Green Indexing

**Recommended Solution** - INSERT trước, DELETE sau.

## Concept

Tương tự Blue-Green Deployment trong DevOps:
1. Deploy version mới (Green) song song với version cũ (Blue)
2. Switch traffic sang Green
3. Cleanup Blue

---

## Implementation

```typescript
async function reindexBlueGreen(documentId: string, content: string) {
  const currentVersion = await redis.get(`version:${documentId}`) || 0;
  const newVersion = currentVersion + 1;

  // 1. INSERT mới TRƯỚC (document vẫn available với version cũ!)
  await qdrant.upsert('chunks', {
    points: chunks.map((c, i) => ({
      id: crypto.randomUUID(),
      vector: c.vector,
      payload: {
        uuid: documentId,
        version: newVersion,
        content: c.content,
        status: 'active'  // <-- Cả v1 và v2 đều 'active'
      }
    }))
  });

  // 2. Cập nhật version pointer trong Redis
  await redis.set(`version:${documentId}`, newVersion);

  // 3. DELETE cũ SAU (theo version number cụ thể)
  await qdrant.delete('chunks', {
    filter: { must: [
      { key: 'uuid', match: { value: documentId } },
      { key: 'version', match: { value: currentVersion } }  // Chỉ xóa version cũ
    ]}
  });
}
```

---

## Search Implementation - Không cần version!

**Câu hỏi quan trọng**: Search tìm version nào?

```typescript
async function search(query: string): Promise<SearchResult[]> {
  const vector = generateEmbedding(query);

  // Chỉ filter theo status='active', KHÔNG filter theo version!
  return qdrant.search(vector, {
    filter: { must: [{ key: 'status', match: { value: 'active' } }] }
  });
}
```

**Giải thích**:
- Search **KHÔNG** cần biết version hiện tại
- Search chỉ tìm chunks có `status: 'active'`
- Cả v1 và v2 đều có `status: 'active'` → Query có thể trả về kết quả từ **cả hai versions**

---

## Timeline Chi Tiết

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ BLUE-GREEN REINDEX TIMELINE                                                  │
├──────┬──────────────────────────────────────────────────────────────────────┤
│ T0   │ [INDEXER] Bắt đầu reindex                                            │
│      │           v1: status='active' (searchable)                           │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T100 │ [INDEXER] INSERT chunks v2 với status='active'                       │
│      │           v1: status='active' (searchable)                           │
│      │           v2: status='active' (searchable)                           │
│      │                                                                       │
│      │ ⚠️  CẢ HAI VERSIONS ĐỀU SEARCHABLE!                                  │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T200 │ [USER] Query "pump specs"                                            │
│      │        → Có thể tìm thấy v1 HOẶC v2 (hoặc cả hai)                   │
│      │        → Trả về stale data (v1) hoặc new data (v2)                  │
│      │        → KHÔNG BAO GIỜ trả về empty result!                          │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T300 │ [INDEXER] Update Redis version pointer                               │
│      │           (Dùng để track version cho DELETE, không cho query)       │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T400 │ [INDEXER] DELETE chunks v1                                           │
│      │           v1: DELETED                                                │
│      │           v2: status='active' (searchable)                           │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T500 │ [USER] Query "pump specs"                                            │
│      │        → Chỉ tìm thấy v2 (data mới nhất)                            │
└──────┴──────────────────────────────────────────────────────────────────────┘

✅ Document LUÔN available! (có thể là v1, v2, hoặc cả hai)
```

---

## FAQ: Câu hỏi thường gặp

### Q1: Trong lúc indexing, user có nhận được stale data không?

**Có, và đây là acceptable behavior!**

Trong khoảng T100-T400:
- Cả v1 (stale) và v2 (new) đều có `status: 'active'`
- Query có thể trả về kết quả từ v1 hoặc v2
- User có thể nhận stale data

**Tại sao acceptable?**
- Better than no data (Baseline trả về empty)
- Eventually consistent - sau khi reindex xong, chỉ còn v2
- Trong thực tế, gap period rất ngắn (vài trăm ms)

### Q2: Redis version pointer dùng để làm gì?

**Redis KHÔNG dùng cho query routing!**

Redis version pointer dùng để:
1. **Track version number**: Biết version tiếp theo là bao nhiêu
2. **Identify old chunks**: Biết chunks nào cần DELETE sau khi insert xong
3. **Recovery**: Biết document đang ở version nào nếu service crash

```typescript
// Redis chỉ dùng trong reindex logic:
const currentVersion = await redis.get(`version:${uuid}`);  // Lấy version hiện tại
await redis.set(`version:${uuid}`, newVersion);              // Cập nhật version mới
```

### Q3: Search tự động point tới v2 như thế nào?

**Search KHÔNG point tới version cụ thể!**

Search mechanism:
1. Filter: `status = 'active'`
2. Trước delete v1: Cả v1 và v2 match filter → có thể trả về cả hai
3. Sau delete v1: Chỉ v2 match filter → chỉ trả về v2

```typescript
// Search code thực tế:
export async function searchWithActiveFilter(vector: number[]): Promise<SearchResult[]> {
  return search(vector, {
    filter: { must: [{ key: 'status', match: { value: 'active' } }] }
    // Không có filter theo version!
  });
}
```

### Q4: Tại sao không filter theo version trong search?

**Để đảm bảo availability!**

Nếu filter theo version:
- Cần lookup Redis trước mỗi query (thêm latency)
- Nếu Redis chậm/unavailable → search fail
- Race condition giữa version update và query

Cách hiện tại đơn giản và safe hơn:
- Search luôn tìm `status='active'`
- Không phụ thuộc vào Redis
- Luôn có kết quả (v1 hoặc v2)

### Q5: Có thể trả về DUPLICATE results không?

**Có! Đây là edge case quan trọng cần xử lý.**

Trong khoảng T100-T400, cả v1 và v2 đều `status='active'`:

```
Query "pump specs" có thể trả về:
┌─────────────────────────────────────────────────────────────┐
│ Results (sorted by similarity score):                        │
├─────────────────────────────────────────────────────────────┤
│ 1. chunk-v2-0  score=0.95  uuid="pump-001"  version=2       │
│ 2. chunk-v1-0  score=0.94  uuid="pump-001"  version=1  ←DUP │
│ 3. chunk-v2-1  score=0.85  uuid="pump-001"  version=2       │
│ 4. chunk-v1-1  score=0.84  uuid="pump-001"  version=1  ←DUP │
└─────────────────────────────────────────────────────────────┘
```

**Tại sao xảy ra?**
- v1 và v2 của cùng content có similar embeddings
- Cả hai đều match filter `status='active'`
- Qdrant trả về top N results by score, không biết về versions

**Giải pháp: Client-side deduplication**

```typescript
// TODO: Implement deduplication in search results
async function searchWithDedup(query: string, limit: number = 10): Promise<SearchResult[]> {
  // Fetch more results to account for duplicates
  const results = await blueGreen.search(query, { limit: limit * 2 });

  // Dedupe by uuid, keep highest score
  const seen = new Map<string, SearchResult>();
  for (const result of results) {
    const uuid = result.payload.uuid;
    if (!seen.has(uuid) || seen.get(uuid)!.score < result.score) {
      seen.set(uuid, result);
    }
  }

  return Array.from(seen.values())
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);
}
```

**Khi nào cần dedup?**
- Nếu application hiển thị results by document → **CẦN dedup**
- Nếu application hiển thị results by chunk → **KHÔNG cần dedup**
- Nếu gap period rất ngắn và traffic thấp → **Có thể bỏ qua**

---

## Edge Cases Summary

| Edge Case | Behavior | Mitigation |
|-----------|----------|------------|
| Duplicate results | v1 + v2 chunks cùng uuid trong results | Client-side dedup by uuid |
| Stale data | User nhận v1 trong lúc v2 đang index | Acceptable (eventually consistent) |
| Mixed versions | Một số chunks từ v1, một số từ v2 | Dedup sẽ giữ highest score |
| Version number overflow | Redis counter vượt quá Number.MAX_SAFE_INTEGER | Unlikely (9007199254740991 versions), có thể reset periodic |
| Redis unavailable | Không lấy được current version | Fallback: start từ version=1, có thể tạo orphan versions |
| Rapid reindex | Nhiều reindex requests liên tiếp cho cùng document | Versions tích lũy nhanh, cần cleanup strategy |
| Delete old version fails | v1 không bị xóa, cả v1+v2 tồn tại mãi | Recovery job tìm documents có >1 version |
| Storage spike | 2x storage trong lúc reindex | Monitor storage, consider rate limiting reindex |

---

## Crash Recovery

| Scenario | Trạng thái | Result |
|----------|------------|--------|
| Crash sau INSERT, trước DELETE | v1 + v2 đều active | ✅ Document có (cả 2 versions, cần cleanup) |
| Crash sau UPDATE pointer | v1 + v2 đều active | ✅ Document có (restart sẽ cleanup v1) |
| Crash trước INSERT | Chỉ v1 active | ✅ Document có (version cũ) |

**Recovery action**: Tìm documents có nhiều versions → cleanup old versions

---

## Benchmark Results

| Metric | Value |
|--------|-------|
| Availability | **100%** |
| Avg Latency | 16ms |
| Storage Overhead | 2x (tạm thời trong lúc reindex) |
| Crash Recovery | ✅ Document vẫn còn |

---

## Ưu điểm

- **Zero downtime**: Document luôn searchable
- **Crash safe**: Không mất data nếu crash
- **Đơn giản**: Search không cần version logic
- **Fast recovery**: Chỉ cần cleanup duplicate versions

## Nhược điểm

- Storage tạm thời gấp đôi (trong lúc reindex)
- Có thể trả về stale data trong lúc reindex (acceptable trade-off)
- Cần version tracking trong Redis

---

## So sánh với các approach khác

| Aspect | Blue-Green | Version-filtered Search |
|--------|------------|------------------------|
| Query latency | Fast (no Redis lookup) | Slower (Redis lookup required) |
| Consistency | Eventual | Strong |
| Availability | 100% | 100% (if Redis available) |
| Complexity | Simple | More complex |
| Redis dependency | Write-only | Read on every query |

**Trade-off**: Blue-Green chọn availability và simplicity thay vì strong consistency.

---

## Source Code

[src/solutions/blue-green.ts](../../src/solutions/blue-green.ts)

---

✅ **Recommended** - Tốt nhất cho hầu hết use cases khi:
- Stale data trong vài trăm ms là acceptable
- Ưu tiên availability over strong consistency
- Muốn implementation đơn giản
