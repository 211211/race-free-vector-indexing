# 2.3 Soft Delete

**Alternative Solution** - Đánh dấu inactive thay vì xóa.

## Concept

Thay vì xóa chunks cũ, chỉ đánh dấu chúng là `inactive`. Search luôn filter `status='active'`.

```
INSERT new (active) → MARK old (inactive)
```

Khác với Blue-Green:
- Blue-Green: Dùng version number, DELETE old version
- Soft-Delete: Dùng status flag, KHÔNG bao giờ DELETE

---

## Implementation

```typescript
async function reindexSoftDelete(documentId: string, content: string) {
  // QUAN TRỌNG: Capture timestamp TRƯỚC khi insert
  const reindexStartTime = Date.now();

  // 1. INSERT new chunks với status='active'
  const chunks = processDocument(content);
  await qdrant.upsert('chunks', {
    points: chunks.map((c, i) => ({
      id: crypto.randomUUID(),
      vector: c.vector,
      payload: {
        uuid: documentId,
        content: c.content,
        status: 'active',      // New chunks are active
        createdAt: Date.now()  // Timestamp for filtering
      }
    }))
  });

  // 2. Mark chunks CŨ (created BEFORE reindexStartTime) thành inactive
  await markInactiveOlderThan(documentId, reindexStartTime);
}
```

---

## Search Implementation

```typescript
async function search(query: string): Promise<SearchResult[]> {
  const vector = generateEmbedding(query);

  // LUÔN filter theo status='active'
  return qdrant.search(vector, {
    filter: { must: [{ key: 'status', match: { value: 'active' } }] }
  });
}
```

**Giống Blue-Green**: Search chỉ filter theo `status='active'`, không dùng version hay timestamp trong query.

---

## Timeline Chi Tiết

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ SOFT-DELETE REINDEX TIMELINE                                                 │
├──────┬──────────────────────────────────────────────────────────────────────┤
│ T0   │ [INDEXER] reindexStartTime = Date.now()                              │
│      │           Old chunks: status='active', createdAt=T(-1000)           │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T100 │ [INDEXER] INSERT new chunks                                          │
│      │           Old: status='active', createdAt=T(-1000)                  │
│      │           New: status='active', createdAt=T100                      │
│      │                                                                       │
│      │ ⚠️  CẢ HAI ĐỀU ACTIVE! (giống Blue-Green)                           │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T200 │ [USER] Query "pump specs"                                            │
│      │        → Filter: status='active'                                     │
│      │        → Có thể tìm thấy old OR new (cả hai đều active)             │
│      │        → KHÔNG BAO GIỜ empty result!                                 │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T300 │ [INDEXER] markInactiveOlderThan(uuid, T0)                            │
│      │           Filter: uuid=X AND status='active' AND createdAt < T0     │
│      │           → Chỉ mark OLD chunks thành inactive                       │
│      │                                                                       │
│      │           Old: status='inactive', createdAt=T(-1000) ← MARKED       │
│      │           New: status='active', createdAt=T100      ← UNCHANGED     │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T400 │ [USER] Query "pump specs"                                            │
│      │        → Filter: status='active'                                     │
│      │        → Chỉ tìm thấy NEW chunks                                     │
└──────┴──────────────────────────────────────────────────────────────────────┘

✅ Document LUÔN available!
```

---

## FAQ: Câu hỏi thường gặp

### Q1: Trong lúc indexing, user nhận data gì?

**Giống Blue-Green**: User có thể nhận old hoặc new data (cả hai đều active).

| Time Period | Old Chunks | New Chunks | User có thể nhận |
|-------------|------------|------------|------------------|
| T0-T100 | active | (chưa có) | Old data |
| T100-T300 | active | active | Old OR New |
| T300+ | inactive | active | New data only |

### Q2: Tại sao cần timestamp trong markInactive?

**Để tránh mark nhầm chunks mới!**

```typescript
// ❌ WRONG: Mark ALL active chunks của uuid này
await markInactive(uuid);
// Bug: Sẽ mark cả chunks mới vừa insert!

// ✅ CORRECT: Chỉ mark chunks CŨ HƠN thời điểm bắt đầu reindex
const reindexStartTime = Date.now();
// ... insert new chunks ...
await markInactiveOlderThan(uuid, reindexStartTime);
// Chỉ chunks có createdAt < reindexStartTime bị mark inactive
```

### Q3: Search tự động ignore inactive như thế nào?

**Bằng filter condition trong mọi query**:

```typescript
// Mọi search call đều có filter này
return qdrant.search(vector, {
  filter: { must: [{ key: 'status', match: { value: 'active' } }] }
});
```

Inactive chunks vẫn tồn tại trong Qdrant nhưng **KHÔNG BAO GIỜ** trả về trong search results.

### Q4: Khác gì với Blue-Green?

| Aspect | Blue-Green | Soft-Delete |
|--------|------------|-------------|
| Old chunks | **DELETE** sau khi insert | **MARK inactive** (không xóa) |
| Storage | 2x tạm thời | 2x+ tích lũy |
| Audit trail | Không có | Có (inactive chunks vẫn còn) |
| Rollback | Không thể | Có thể (flip status) |
| Cleanup | Automatic (DELETE) | Manual (cleanup job cần thiết) |

### Q5: User có thể query inactive chunks không?

**Có, nếu cần audit**:

```typescript
// Special query for audit purposes
async function searchAllVersions(query: string) {
  return qdrant.search(vector, {
    // Không filter status → trả về cả active và inactive
  });
}

// Hoặc chỉ inactive
async function searchInactive(query: string) {
  return qdrant.search(vector, {
    filter: { must: [{ key: 'status', match: { value: 'inactive' } }] }
  });
}
```

### Q6: Có thể trả về DUPLICATE results không?

**Có! Giống hệt Blue-Green - đây là edge case cần xử lý.**

Trong khoảng T100-T300, cả old và new chunks đều `status='active'`:

```
Query "pump specs" có thể trả về:
┌─────────────────────────────────────────────────────────────────┐
│ Results (sorted by similarity score):                            │
├─────────────────────────────────────────────────────────────────┤
│ 1. chunk-new-0  score=0.95  uuid="pump-001"  createdAt=T100     │
│ 2. chunk-old-0  score=0.94  uuid="pump-001"  createdAt=T(-1000) │ ←DUP
│ 3. chunk-new-1  score=0.85  uuid="pump-001"  createdAt=T100     │
│ 4. chunk-old-1  score=0.84  uuid="pump-001"  createdAt=T(-1000) │ ←DUP
└─────────────────────────────────────────────────────────────────┘
```

**Tại sao xảy ra?**
- Old và new chunks của cùng content có similar embeddings
- Cả hai đều match filter `status='active'`
- Qdrant trả về top N results by score

**Giải pháp: Client-side deduplication**

```typescript
// TODO: Implement deduplication in search results
async function searchWithDedup(query: string, limit: number = 10): Promise<SearchResult[]> {
  // Fetch more results to account for duplicates
  const results = await softDelete.search(query, { limit: limit * 2 });

  // Dedupe by uuid, keep highest score (usually newest version)
  const seen = new Map<string, SearchResult>();
  for (const result of results) {
    const uuid = result.payload.uuid;
    if (!seen.has(uuid) || seen.get(uuid)!.score < result.score) {
      seen.set(uuid, result);
    }
  }

  return Array.from(seen.values())
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);
}
```

**Alternative: Dedup by uuid + keep newest (by createdAt)**

```typescript
// TODO: Alternative - keep newest version instead of highest score
async function searchWithDedupByTime(query: string, limit: number = 10): Promise<SearchResult[]> {
  const results = await softDelete.search(query, { limit: limit * 2 });

  // Dedupe by uuid, keep newest createdAt
  const seen = new Map<string, SearchResult>();
  for (const result of results) {
    const uuid = result.payload.uuid;
    const existing = seen.get(uuid);
    if (!existing || existing.payload.createdAt < result.payload.createdAt) {
      seen.set(uuid, result);
    }
  }

  return Array.from(seen.values())
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);
}
```

---

## Edge Cases Summary

| Edge Case | Behavior | Mitigation |
|-----------|----------|------------|
| Duplicate results | Old + new chunks cùng uuid trong results | Client-side dedup by uuid |
| Stale data | User nhận old trong lúc new đang index | Acceptable (eventually consistent) |
| Mixed versions | Một số chunks old, một số new | Dedup giữ highest score hoặc newest |
| Inactive in results | Không bao giờ (filter by status) | Built-in via search filter |
| Storage bloat | Inactive chunks tích lũy vô hạn | **CRITICAL**: Cleanup job bắt buộc |
| Clock skew | Server time không đồng bộ giữa các nodes | Dùng centralized timestamp (Redis) hoặc logical clock |
| Timestamp collision | 2 reindex cùng ms → markInactive sai | Dùng high-resolution timestamp hoặc add random suffix |
| Index performance | Qdrant index chứa cả inactive → slower queries | Periodic hard delete của inactive chunks |
| Rollback complexity | Muốn rollback nhưng có nhiều inactive versions | Cần track version history, không chỉ status |
| Cleanup job failure | Cleanup không chạy → storage exhausted | Monitor inactive chunk count, alert threshold |
| Partial mark inactive | Crash giữa chừng mark → một số old chunks vẫn active | Recovery: re-run markInactiveOlderThan |

---

## Crash Recovery

| Scenario | Trạng thái | Result |
|----------|------------|--------|
| Crash trước INSERT | Chỉ old active | ✅ Document có (old version) |
| Crash sau INSERT, trước MARK | Both active | ✅ Document có (cả hai, cần cleanup) |
| Crash sau MARK | Old inactive, new active | ✅ Document có (new version) |

**Recovery action**: Tìm documents có nhiều active chunks → re-run mark inactive.

---

## Cleanup Job

**QUAN TRỌNG**: Soft-Delete cần cleanup job định kỳ!

```typescript
// Chạy định kỳ (daily/weekly) để xóa inactive chunks cũ
async function cleanupInactiveChunks(olderThanDays: number) {
  const threshold = Date.now() - olderThanDays * 24 * 60 * 60 * 1000;

  await qdrant.delete('chunks', {
    filter: { must: [
      { key: 'status', match: { value: 'inactive' } },
      { key: 'createdAt', range: { lt: threshold } }
    ]}
  });
}

// Ví dụ: Xóa inactive chunks older than 30 days
await cleanupInactiveChunks(30);
```

**Không cleanup = Storage tích lũy vô hạn!**

---

## Benchmark Results

| Metric | Value |
|--------|-------|
| Availability | **100%** |
| Avg Latency | 38ms (cao hơn do update status) |
| Storage Overhead | +20-50% (tích lũy theo thời gian) |
| Crash Recovery | ✅ Document vẫn còn |

---

## Ưu điểm

- **Zero downtime**: Document luôn searchable
- **Audit trail**: Có thể xem lại chunks cũ
- **Easy rollback**: Chỉ cần flip status back to active
- **Crash safe**: Không mất data
- **History retention**: Giữ lại tất cả versions

## Nhược điểm

- **Storage overhead**: Tích lũy theo thời gian
- **Cleanup job required**: Cần maintain cleanup job
- **Higher latency**: Do update status operation
- **Index bloat**: Qdrant index chứa cả inactive chunks

---

## So sánh Trade-offs

| Use Case | Recommended Solution |
|----------|---------------------|
| Simple reindex, no audit needed | Blue-Green |
| Need audit trail | **Soft-Delete** |
| Need rollback capability | **Soft-Delete** |
| Limited storage | Blue-Green |
| Compliance/regulatory requirements | **Soft-Delete** |

---

## Source Code

[src/solutions/soft-delete.ts](../../src/solutions/soft-delete.ts)

---

✅ **Tốt** - Recommended khi:
- Cần audit trail
- Cần khả năng rollback
- Có compliance requirements
- Có storage đủ lớn và cleanup job
