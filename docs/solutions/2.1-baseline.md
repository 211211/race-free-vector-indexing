# 2.1 Baseline (DELETE-THEN-INSERT)

**Pattern có vấn đề** - Đây là cách tiếp cận phổ biến nhưng tạo ra race condition.

## Concept

Pattern đơn giản nhất: xóa hết chunks cũ, insert chunks mới.

```
DELETE old → [GAP] → INSERT new
```

---

## Implementation

```typescript
async function reindexBaseline(documentId: string, content: string) {
  // Step 1: DELETE tất cả chunks cũ
  await qdrant.delete('chunks', {
    filter: { must: [{ key: 'uuid', match: { value: documentId } }] }
  });

  // ⚠️ GAP: Document KHÔNG TÌM THẤY trong khoảng thời gian này!

  // Step 2: Process content thành chunks
  const chunks = processDocument(content);

  // Step 3: INSERT chunks mới
  await qdrant.upsert('chunks', {
    points: chunks.map((c, i) => ({
      id: crypto.randomUUID(),
      vector: c.vector,
      payload: {
        uuid: documentId,
        chunkIndex: i,
        content: c.content,
        createdAt: Date.now()
      }
    }))
  });
}
```

---

## Search Implementation

```typescript
async function search(query: string): Promise<SearchResult[]> {
  const vector = generateEmbedding(query);

  // Search đơn giản - không filter gì cả
  return qdrant.search(vector, { limit: 10 });
}
```

**Vấn đề**: Trong khoảng GAP, search trả về **empty results**!

---

## Timeline Chi Tiết

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ BASELINE REINDEX TIMELINE                                                    │
├──────┬──────────────────────────────────────────────────────────────────────┤
│ T0   │ [INDEXER] Bắt đầu reindex document "DOC-001"                         │
│      │           Chunks: [chunk1, chunk2, chunk3] (searchable)             │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T100 │ [INDEXER] DELETE tất cả chunks                                       │
│      │           Chunks: [] (EMPTY!)                                        │
│      │                                                                       │
│      │ ⚠️  DOCUMENT BIẾN MẤT!                                               │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T200 │ [USER] Query "pump specs"                                            │
│      │        → Search trong Qdrant                                         │
│      │        → Không có chunks nào match                                   │
│      │        → Return EMPTY RESULTS!                                       │
│      │                                                                       │
│      │ ❌ USER KHÔNG TÌM THẤY DOCUMENT!                                     │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T300 │ [INDEXER] Process content (split, embedding)                         │
│      │           Chunks: [] (vẫn empty trong Qdrant)                        │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T500 │ [INDEXER] INSERT chunks mới                                          │
│      │           Chunks: [chunk1', chunk2', chunk3'] (searchable again)    │
├──────┼──────────────────────────────────────────────────────────────────────┤
│ T600 │ [USER] Query "pump specs"                                            │
│      │        → Tìm thấy document (version mới)                            │
└──────┴──────────────────────────────────────────────────────────────────────┘

     |<────────────── GAP: 400ms ──────────────>|
     T100                                      T500
     (DELETE)                                  (INSERT complete)
```

---

## FAQ: Các vấn đề chi tiết

### Q1: Gap period bao lâu?

**Phụ thuộc vào content size và system load**:
- Small doc (1 page): ~100-500ms
- Medium doc (10 pages): ~500ms-2s
- Large doc (100+ pages): vài giây đến phút

Gap = Time(process content) + Time(generate embeddings) + Time(insert chunks)

### Q2: Tại sao availability chỉ ~38%?

Benchmark chạy concurrent queries trong lúc reindex:
- 20 queries total
- 12 queries hit trong lúc GAP → empty results
- 8 queries hit trước/sau GAP → có results
- Availability = 8/20 = 40% (dao động ~38%)

### Q3: Crash recovery như thế nào?

**KHÔNG CÓ RECOVERY!**

| Crash Point | Result |
|-------------|--------|
| Sau DELETE, trước INSERT | ❌ Document **MẤT VĨNH VIỄN** |
| Trong lúc INSERT | ❌ Document **MẤT hoặc PARTIAL** |
| Sau INSERT | ✅ Document OK |

```
DELETE → [CRASH] → INSERT (never happens)
         ↓
   Document LOST forever!
```

### Q4: Concurrent reindex có safe không?

**KHÔNG!**

```
Thread A: DELETE doc-001
Thread B: DELETE doc-001
Thread A: INSERT chunks v1
Thread B: INSERT chunks v2
Result: Cả v1 và v2 tồn tại → Data corruption!
```

Hoặc tệ hơn:
```
Thread A: DELETE doc-001
Thread B: DELETE doc-001
Thread A: INSERT chunks v1
Thread B: DELETE (again, do timing) → xóa luôn v1!
Result: Document LOST!
```

### Q5: Có duplicate results như Blue-Green/Soft-Delete không?

**KHÔNG có duplicate trong normal operation!**

Baseline DELETE trước, INSERT sau → chỉ có 1 version tồn tại tại một thời điểm:

```
Timeline:
T0:   [v1 chunks exist]           → Query returns v1
T100: [DELETE v1]                 → Query returns EMPTY ❌
T200: [processing...]             → Query returns EMPTY ❌
T400: [INSERT v2]                 → Query returns v2
```

**Nhưng concurrent reindex có thể gây duplicate!** (xem Q4)

---

## Edge Cases Summary

| Edge Case | Behavior | Mitigation |
|-----------|----------|------------|
| Empty results (GAP) | User query trả về 0 results trong lúc reindex | **KHÔNG CÓ MITIGATION** ❌ |
| Data loss on crash | Document mất vĩnh viễn nếu crash sau DELETE | **KHÔNG CÓ MITIGATION** ❌ |
| Concurrent reindex | Multiple versions hoặc data loss | Cần external locking |
| Partial insert failure | Một số chunks insert thành công, một số fail | Document bị corrupt (incomplete) |
| Long processing time | Large documents → GAP kéo dài nhiều giây/phút | User experience rất tệ |
| Network timeout | Delete thành công, insert timeout → data loss | Retry không giúp (đã delete rồi) |
| Qdrant restart | Nếu Qdrant restart giữa DELETE và INSERT | Data loss (delete đã persist) |
| Embedding service down | Delete xong, embedding fail → không insert được | Data loss |
| Out of memory | Process large doc, OOM kill → crash | Data loss |

**Kết luận**: Baseline có RẤT NHIỀU failure modes dẫn đến data loss. Không nên dùng cho production.

---

## So sánh với các Solutions khác

| Aspect | Baseline | Blue-Green | Soft-Delete |
|--------|----------|------------|-------------|
| Gap period | ~400ms+ | **0ms** | **0ms** |
| Query trong gap | Empty | Has results | Has results |
| Crash recovery | ❌ Lost | ✅ Safe | ✅ Safe |
| Concurrent safe | ❌ No | ✅ Yes | ✅ Yes |
| Complexity | Simple | Medium | Medium |
| Storage overhead | None | 2x temp | 2x temp |

---

## Benchmark Results

| Metric | Value |
|--------|-------|
| Availability | **~38%** (very poor) |
| Avg Latency | 5ms |
| Crash Recovery | ❌ Document LOST |
| Storage Overhead | Không |
| Concurrent Safety | ❌ Data corruption risk |

---

## Khi nào có thể dùng?

- Development/testing only
- Non-critical data
- Khi không có users query trong lúc reindex
- Prototype/POC
- Single-threaded environment với full control

---

## Code Flow

```
reindex(uuid, content)
    │
    ├─1─► deleteByUuid(uuid)
    │     └─► Qdrant DELETE filter: uuid = X
    │         ⚠️ Document GONE from this point!
    │
    ├─2─► processDocument(content)
    │     ├─► splitIntoChunks(content)
    │     └─► generateEmbedding(chunk) x N
    │         (này là phần tốn thời gian nhất)
    │
    └─3─► upsertChunks(chunks)
          └─► Qdrant UPSERT points
              ✅ Document available again!
```

---

## Source Code

[src/solutions/baseline.ts](../../src/solutions/baseline.ts)

---

❌ **Không khuyến nghị** - Tránh sử dụng trong production vì:
1. Users sẽ thấy empty results trong lúc reindex
2. Document có thể mất vĩnh viễn nếu crash
3. Không safe với concurrent operations
